{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport { getUserAgent } from '@primeuix/utils/dom';\nimport InputText from 'primevue/inputtext';\nimport { mergeProps, resolveComponent, openBlock, createBlock, normalizeClass } from 'vue';\nimport BaseInput from '@primevue/core/baseinput';\nimport InputMaskStyle from 'primevue/inputmask/style';\nvar script$1 = {\n  name: 'BaseInputMask',\n  \"extends\": BaseInput,\n  props: {\n    slotChar: {\n      type: String,\n      \"default\": '_'\n    },\n    id: {\n      type: String,\n      \"default\": null\n    },\n    \"class\": {\n      type: [String, Object],\n      \"default\": null\n    },\n    mask: {\n      type: String,\n      \"default\": null\n    },\n    placeholder: {\n      type: String,\n      \"default\": null\n    },\n    autoClear: {\n      type: Boolean,\n      \"default\": true\n    },\n    unmask: {\n      type: Boolean,\n      \"default\": false\n    },\n    readonly: {\n      type: Boolean,\n      \"default\": false\n    }\n  },\n  style: InputMaskStyle,\n  provide: function provide() {\n    return {\n      $pcInputMask: this,\n      $parentInstance: this\n    };\n  }\n};\nvar script = {\n  name: 'InputMask',\n  \"extends\": script$1,\n  inheritAttrs: false,\n  emits: ['focus', 'blur', 'keydown', 'complete', 'keypress', 'paste'],\n  inject: {\n    $pcFluid: {\n      \"default\": null\n    }\n  },\n  data: function data() {\n    return {\n      currentVal: ''\n    };\n  },\n  watch: {\n    mask: function mask(newMask, oldMask) {\n      if (oldMask !== newMask) {\n        this.initMask();\n      }\n    }\n  },\n  mounted: function mounted() {\n    this.initMask();\n  },\n  updated: function updated() {\n    if (this.isValueUpdated()) {\n      this.updateValue();\n    }\n  },\n  methods: {\n    onInput: function onInput(event) {\n      // Check if the event is part of a text composition process (e.g., for Asian languages).\n      // If event.isComposing is true, it means the user is still composing text and the input is not finalized.\n      if (!event.isComposing) {\n        if (this.androidChrome) this.handleAndroidInput(event);else this.handleInputChange(event);\n        this.updateModelValue(event.target.value);\n      }\n    },\n    onFocus: function onFocus(event) {\n      var _this = this;\n      if (this.readonly) {\n        return;\n      }\n      this.focus = true;\n      clearTimeout(this.caretTimeoutId);\n      var pos;\n      this.focusText = this.$el.value;\n      pos = this.checkVal();\n      this.caretTimeoutId = setTimeout(function () {\n        if (_this.$el !== document.activeElement) {\n          return;\n        }\n        _this.writeBuffer();\n        if (pos === _this.mask.replace('?', '').length) {\n          _this.caret(0, pos);\n        } else {\n          _this.caret(pos);\n        }\n      }, 10);\n      this.$emit('focus', event);\n    },\n    onBlur: function onBlur(event) {\n      var _this$formField$onBlu, _this$formField;\n      this.focus = false;\n      this.checkVal();\n      this.updateModelValue(event.target.value);\n      if (this.$el.value !== this.focusText) {\n        var e = document.createEvent('HTMLEvents');\n        e.initEvent('change', true, false);\n        this.$el.dispatchEvent(e);\n      }\n      this.$emit('blur', event);\n      (_this$formField$onBlu = (_this$formField = this.formField).onBlur) === null || _this$formField$onBlu === void 0 || _this$formField$onBlu.call(_this$formField, event);\n    },\n    onKeyDown: function onKeyDown(event) {\n      if (this.readonly) {\n        return;\n      }\n      var k = event.code,\n        pos,\n        begin,\n        end;\n      var iPhone = /iphone/i.test(getUserAgent());\n      this.oldVal = this.$el.value;\n\n      //backspace, delete, and escape get special treatment\n      if (k === 'Backspace' || k === 'Delete' || iPhone && k === 'Escape') {\n        pos = this.caret();\n        begin = pos.begin;\n        end = pos.end;\n        if (end - begin === 0) {\n          begin = k !== 'Delete' ? this.seekPrev(begin) : end = this.seekNext(begin - 1);\n          end = k === 'Delete' ? this.seekNext(end) : end;\n        }\n        this.clearBuffer(begin, end);\n        this.shiftL(begin, end - 1);\n        this.updateModelValue(event.target.value);\n        event.preventDefault();\n      } else if (k === 'Enter') {\n        // enter\n        this.$el.blur();\n        this.updateModelValue(event.target.value);\n      } else if (k === 'Escape') {\n        // escape\n        this.$el.value = this.focusText;\n        this.caret(0, this.checkVal());\n        this.updateModelValue(event.target.value);\n        event.preventDefault();\n      }\n      this.$emit('keydown', event);\n    },\n    onKeyPress: function onKeyPress(event) {\n      var _this2 = this;\n      if (this.readonly) {\n        return;\n      }\n      var k = event.code,\n        pos = this.caret(),\n        p,\n        c,\n        next,\n        completed;\n      if (event.ctrlKey || event.altKey || event.metaKey || event.shiftKey || event.key === 'CapsLock' || event.key === 'Escape' || event.key === 'Tab') {\n        //Ignore\n        return;\n      } else if (k && k !== 'Enter') {\n        if (pos.end - pos.begin !== 0) {\n          this.clearBuffer(pos.begin, pos.end);\n          this.shiftL(pos.begin, pos.end - 1);\n        }\n        p = this.seekNext(pos.begin - 1);\n        if (p < this.len) {\n          c = event.key;\n          if (this.tests[p].test(c)) {\n            this.shiftR(p);\n            this.buffer[p] = c;\n            this.writeBuffer();\n            next = this.seekNext(p);\n            if (/android/i.test(getUserAgent())) {\n              //Path for CSP Violation on FireFox OS 1.1\n              var proxy = function proxy() {\n                _this2.caret(next);\n              };\n              setTimeout(proxy, 0);\n            } else {\n              this.caret(next);\n            }\n            if (pos.begin <= this.lastRequiredNonMaskPos) {\n              completed = this.isCompleted();\n            }\n          }\n        }\n        event.preventDefault();\n      }\n      this.updateModelValue(event.target.value);\n      if (completed) {\n        this.$emit('complete', event);\n      }\n      this.$emit('keypress', event);\n    },\n    onPaste: function onPaste(event) {\n      this.handleInputChange(event);\n      this.$emit('paste', event);\n    },\n    caret: function caret(first, last) {\n      var range, begin, end;\n      if (!this.$el.offsetParent || this.$el !== document.activeElement) {\n        return;\n      }\n      if (typeof first === 'number') {\n        begin = first;\n        end = typeof last === 'number' ? last : begin;\n        if (this.$el.setSelectionRange) {\n          this.$el.setSelectionRange(begin, end);\n        } else if (this.$el['createTextRange']) {\n          range = this.$el['createTextRange']();\n          range.collapse(true);\n          range.moveEnd('character', end);\n          range.moveStart('character', begin);\n          range.select();\n        }\n      } else {\n        if (this.$el.setSelectionRange) {\n          begin = this.$el.selectionStart;\n          end = this.$el.selectionEnd;\n        } else if (document['selection'] && document['selection'].createRange) {\n          range = document['selection'].createRange();\n          begin = 0 - range.duplicate().moveStart('character', -100000);\n          end = begin + range.text.length;\n        }\n        return {\n          begin: begin,\n          end: end\n        };\n      }\n    },\n    isCompleted: function isCompleted() {\n      for (var i = this.firstNonMaskPos; i <= this.lastRequiredNonMaskPos; i++) {\n        if (this.tests[i] && this.buffer[i] === this.getPlaceholder(i)) {\n          return false;\n        }\n      }\n      return true;\n    },\n    getPlaceholder: function getPlaceholder(i) {\n      if (i < this.slotChar.length) {\n        return this.slotChar.charAt(i);\n      }\n      return this.slotChar.charAt(0);\n    },\n    seekNext: function seekNext(pos) {\n      while (++pos < this.len && !this.tests[pos]);\n      return pos;\n    },\n    seekPrev: function seekPrev(pos) {\n      while (--pos >= 0 && !this.tests[pos]);\n      return pos;\n    },\n    shiftL: function shiftL(begin, end) {\n      var i, j;\n      if (begin < 0) {\n        return;\n      }\n      for (i = begin, j = this.seekNext(end); i < this.len; i++) {\n        if (this.tests[i]) {\n          if (j < this.len && this.tests[i].test(this.buffer[j])) {\n            this.buffer[i] = this.buffer[j];\n            this.buffer[j] = this.getPlaceholder(j);\n          } else {\n            break;\n          }\n          j = this.seekNext(j);\n        }\n      }\n      this.writeBuffer();\n      this.caret(Math.max(this.firstNonMaskPos, begin));\n    },\n    shiftR: function shiftR(pos) {\n      var i, c, j, t;\n      for (i = pos, c = this.getPlaceholder(pos); i < this.len; i++) {\n        if (this.tests[i]) {\n          j = this.seekNext(i);\n          t = this.buffer[i];\n          this.buffer[i] = c;\n          if (j < this.len && this.tests[j].test(t)) {\n            c = t;\n          } else {\n            break;\n          }\n        }\n      }\n    },\n    handleAndroidInput: function handleAndroidInput(event) {\n      var curVal = this.$el.value;\n      var pos = this.caret();\n      if (this.oldVal && this.oldVal.length && this.oldVal.length > curVal.length) {\n        // a deletion or backspace happened\n        this.checkVal(true);\n        while (pos.begin > 0 && !this.tests[pos.begin - 1]) pos.begin--;\n        if (pos.begin === 0) {\n          while (pos.begin < this.firstNonMaskPos && !this.tests[pos.begin]) pos.begin++;\n        }\n        this.caret(pos.begin, pos.begin);\n      } else {\n        this.checkVal(true);\n        while (pos.begin < this.len && !this.tests[pos.begin]) pos.begin++;\n        this.caret(pos.begin, pos.begin);\n      }\n      if (this.isCompleted()) {\n        this.$emit('complete', event);\n      }\n    },\n    clearBuffer: function clearBuffer(start, end) {\n      var i;\n      for (i = start; i < end && i < this.len; i++) {\n        if (this.tests[i]) {\n          this.buffer[i] = this.getPlaceholder(i);\n        }\n      }\n    },\n    writeBuffer: function writeBuffer() {\n      this.$el.value = this.buffer.join('');\n    },\n    checkVal: function checkVal(allow) {\n      this.isValueChecked = true;\n      //try to place characters where they belong\n      var test = this.$el.value,\n        lastMatch = -1,\n        i,\n        c,\n        pos;\n      for (i = 0, pos = 0; i < this.len; i++) {\n        if (this.tests[i]) {\n          this.buffer[i] = this.getPlaceholder(i);\n          while (pos++ < test.length) {\n            c = test.charAt(pos - 1);\n            if (this.tests[i].test(c)) {\n              this.buffer[i] = c;\n              lastMatch = i;\n              break;\n            }\n          }\n          if (pos > test.length) {\n            this.clearBuffer(i + 1, this.len);\n            break;\n          }\n        } else {\n          if (this.buffer[i] === test.charAt(pos)) {\n            pos++;\n          }\n          if (i < this.partialPosition) {\n            lastMatch = i;\n          }\n        }\n      }\n      if (allow) {\n        this.writeBuffer();\n      } else if (lastMatch + 1 < this.partialPosition) {\n        if (this.autoClear || this.buffer.join('') === this.defaultBuffer) {\n          // Invalid value. Remove it and replace it with the\n          // mask, which is the default behavior.\n          if (this.$el.value) this.$el.value = '';\n          this.clearBuffer(0, this.len);\n        } else {\n          // Invalid value, but we opt to show the value to the\n          // user and allow them to correct their mistake.\n          this.writeBuffer();\n        }\n      } else {\n        this.writeBuffer();\n        this.$el.value = this.$el.value.substring(0, lastMatch + 1);\n      }\n      return this.partialPosition ? i : this.firstNonMaskPos;\n    },\n    handleInputChange: function handleInputChange(event) {\n      var isPasteEvent = event.type === 'paste';\n      if (this.readonly || isPasteEvent) {\n        return;\n      }\n      var pos = this.checkVal(true);\n      this.caret(pos);\n      this.updateModelValue(event.target.value);\n      if (this.isCompleted()) {\n        this.$emit('complete', event);\n      }\n    },\n    getUnmaskedValue: function getUnmaskedValue() {\n      var unmaskedBuffer = [];\n      for (var i = 0; i < this.buffer.length; i++) {\n        var c = this.buffer[i];\n        if (this.tests[i] && c !== this.getPlaceholder(i)) {\n          unmaskedBuffer.push(c);\n        }\n      }\n      return unmaskedBuffer.join('');\n    },\n    updateModelValue: function updateModelValue(value) {\n      if (this.currentVal === value) return;\n      var val = this.unmask ? this.getUnmaskedValue() : value;\n      this.currentVal = value;\n      this.writeValue(this.defaultBuffer !== val ? val : '');\n    },\n    updateValue: function updateValue() {\n      var _this3 = this;\n      var updateModel = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n      if (this.$el) {\n        if (this.d_value == null) {\n          this.$el.value = '';\n          updateModel && this.updateModelValue('');\n        } else {\n          this.$el.value = this.d_value;\n          this.checkVal();\n          setTimeout(function () {\n            if (_this3.$el) {\n              _this3.writeBuffer();\n              _this3.checkVal();\n              if (updateModel) _this3.updateModelValue(_this3.$el.value);\n            }\n          }, 10);\n        }\n        this.focusText = this.$el.value;\n      }\n    },\n    initMask: function initMask() {\n      this.tests = [];\n      this.partialPosition = this.mask.length;\n      this.len = this.mask.length;\n      this.firstNonMaskPos = null;\n      this.defs = {\n        9: '[0-9]',\n        a: '[A-Za-z]',\n        '*': '[A-Za-z0-9]'\n      };\n      var ua = getUserAgent();\n      this.androidChrome = /chrome/i.test(ua) && /android/i.test(ua);\n      var maskTokens = this.mask.split('');\n      for (var i = 0; i < maskTokens.length; i++) {\n        var c = maskTokens[i];\n        if (c === '?') {\n          this.len--;\n          this.partialPosition = i;\n        } else if (this.defs[c]) {\n          this.tests.push(new RegExp(this.defs[c]));\n          if (this.firstNonMaskPos === null) {\n            this.firstNonMaskPos = this.tests.length - 1;\n          }\n          if (i < this.partialPosition) {\n            this.lastRequiredNonMaskPos = this.tests.length - 1;\n          }\n        } else {\n          this.tests.push(null);\n        }\n      }\n      this.buffer = [];\n      for (var _i = 0; _i < maskTokens.length; _i++) {\n        var _c = maskTokens[_i];\n        if (_c !== '?') {\n          if (this.defs[_c]) this.buffer.push(this.getPlaceholder(_i));else this.buffer.push(_c);\n        }\n      }\n      this.defaultBuffer = this.buffer.join('');\n      this.updateValue(false);\n    },\n    isValueUpdated: function isValueUpdated() {\n      return this.unmask ? this.d_value != this.getUnmaskedValue() : this.defaultBuffer !== this.$el.value && this.$el.value !== this.d_value;\n    }\n  },\n  computed: {\n    inputClass: function inputClass() {\n      return [this.cx('root'), this[\"class\"]];\n    },\n    rootPTOptions: function rootPTOptions() {\n      return {\n        root: mergeProps(this.ptm('pcInputText', this.ptmParams), this.ptmi('root', this.ptmParams))\n      };\n    },\n    ptmParams: function ptmParams() {\n      return {\n        context: {\n          filled: this.$filled\n        }\n      };\n    }\n  },\n  components: {\n    InputText: InputText\n  }\n};\nfunction render(_ctx, _cache, $props, $setup, $data, $options) {\n  var _component_InputText = resolveComponent(\"InputText\");\n  return openBlock(), createBlock(_component_InputText, {\n    id: _ctx.id,\n    value: $data.currentVal,\n    \"class\": normalizeClass($options.inputClass),\n    readonly: _ctx.readonly,\n    disabled: _ctx.disabled,\n    invalid: _ctx.invalid,\n    size: _ctx.size,\n    name: _ctx.name,\n    variant: _ctx.variant,\n    placeholder: _ctx.placeholder,\n    fluid: _ctx.$fluid,\n    unstyled: _ctx.unstyled,\n    onInput: $options.onInput,\n    onCompositionend: $options.onInput,\n    onFocus: $options.onFocus,\n    onBlur: $options.onBlur,\n    onKeydown: $options.onKeyDown,\n    onKeypress: $options.onKeyPress,\n    onPaste: $options.onPaste,\n    pt: $options.rootPTOptions\n  }, null, 8, [\"id\", \"value\", \"class\", \"readonly\", \"disabled\", \"invalid\", \"size\", \"name\", \"variant\", \"placeholder\", \"fluid\", \"unstyled\", \"onInput\", \"onCompositionend\", \"onFocus\", \"onBlur\", \"onKeydown\", \"onKeypress\", \"onPaste\", \"pt\"]);\n}\nscript.render = render;\nexport { script as default };","map":{"version":3,"names":["script$1","name","BaseInput","props","slotChar","type","String","id","Object","mask","placeholder","autoClear","Boolean","unmask","readonly","style","InputMaskStyle","provide","$pcInputMask","$parentInstance","script","inheritAttrs","emits","inject","$pcFluid","data","currentVal","watch","newMask","oldMask","initMask","mounted","updated","isValueUpdated","updateValue","methods","onInput","event","isComposing","androidChrome","handleAndroidInput","handleInputChange","updateModelValue","target","value","onFocus","_this","focus","clearTimeout","caretTimeoutId","pos","focusText","$el","checkVal","setTimeout","document","activeElement","writeBuffer","replace","length","caret","$emit","onBlur","_this$formField$onBlu","_this$formField","e","createEvent","initEvent","dispatchEvent","formField","call","onKeyDown","k","code","begin","end","iPhone","test","getUserAgent","oldVal","seekPrev","seekNext","clearBuffer","shiftL","preventDefault","blur","onKeyPress","_this2","p","c","next","completed","ctrlKey","altKey","metaKey","shiftKey","key","len","tests","shiftR","buffer","proxy","lastRequiredNonMaskPos","isCompleted","onPaste","first","last","range","offsetParent","setSelectionRange","collapse","moveEnd","moveStart","select","selectionStart","selectionEnd","createRange","duplicate","text","i","firstNonMaskPos","getPlaceholder","charAt","j","Math","max","t","curVal","start","join","allow","isValueChecked","lastMatch","partialPosition","defaultBuffer","substring","isPasteEvent","getUnmaskedValue","unmaskedBuffer","push","val","writeValue","_this3","updateModel","arguments","undefined","d_value","defs","a","ua","maskTokens","split","RegExp","_i","_c","computed","inputClass","cx","rootPTOptions","root","mergeProps","ptm","ptmParams","ptmi","context","filled","$filled","components","InputText","createBlock","_component_InputText","_ctx","$data","normalizeClass","$options","disabled","invalid","size","variant","fluid","$fluid","unstyled","onCompositionend","onKeydown","onKeypress","pt"],"sources":["../../src/inputmask/BaseInputMask.vue","../../src/inputmask/InputMask.vue","../../src/inputmask/InputMask.vue?vue&type=template&id=579dc6fa&lang.js"],"sourcesContent":["<script>\nimport BaseInput from '@primevue/core/baseinput';\nimport InputMaskStyle from 'primevue/inputmask/style';\n\nexport default {\n    name: 'BaseInputMask',\n    extends: BaseInput,\n    props: {\n        slotChar: {\n            type: String,\n            default: '_'\n        },\n        id: {\n            type: String,\n            default: null\n        },\n        class: {\n            type: [String, Object],\n            default: null\n        },\n        mask: {\n            type: String,\n            default: null\n        },\n        placeholder: {\n            type: String,\n            default: null\n        },\n        autoClear: {\n            type: Boolean,\n            default: true\n        },\n        unmask: {\n            type: Boolean,\n            default: false\n        },\n        readonly: {\n            type: Boolean,\n            default: false\n        }\n    },\n    style: InputMaskStyle,\n    provide() {\n        return {\n            $pcInputMask: this,\n            $parentInstance: this\n        };\n    }\n};\n</script>\n","<template>\n    <InputText\n        :id=\"id\"\n        :value=\"currentVal\"\n        :class=\"inputClass\"\n        :readonly=\"readonly\"\n        :disabled=\"disabled\"\n        :invalid=\"invalid\"\n        :size=\"size\"\n        :name=\"name\"\n        :variant=\"variant\"\n        :placeholder=\"placeholder\"\n        :fluid=\"$fluid\"\n        :unstyled=\"unstyled\"\n        @input=\"onInput\"\n        @compositionend=\"onInput\"\n        @focus=\"onFocus\"\n        @blur=\"onBlur\"\n        @keydown=\"onKeyDown\"\n        @keypress=\"onKeyPress\"\n        @paste=\"onPaste\"\n        :pt=\"rootPTOptions\"\n    />\n</template>\n\n<script>\nimport { getUserAgent } from '@primeuix/utils/dom';\nimport InputText from 'primevue/inputtext';\nimport { mergeProps } from 'vue';\nimport BaseInputMask from './BaseInputMask.vue';\n\nexport default {\n    name: 'InputMask',\n    extends: BaseInputMask,\n    inheritAttrs: false,\n    emits: ['focus', 'blur', 'keydown', 'complete', 'keypress', 'paste'],\n    inject: {\n        $pcFluid: { default: null }\n    },\n    data() {\n        return {\n            currentVal: ''\n        };\n    },\n    watch: {\n        mask(newMask, oldMask) {\n            if (oldMask !== newMask) {\n                this.initMask();\n            }\n        }\n    },\n    mounted() {\n        this.initMask();\n    },\n    updated() {\n        if (this.isValueUpdated()) {\n            this.updateValue();\n        }\n    },\n    methods: {\n        onInput(event) {\n            // Check if the event is part of a text composition process (e.g., for Asian languages).\n            // If event.isComposing is true, it means the user is still composing text and the input is not finalized.\n            if (!event.isComposing) {\n                if (this.androidChrome) this.handleAndroidInput(event);\n                else this.handleInputChange(event);\n\n                this.updateModelValue(event.target.value);\n            }\n        },\n        onFocus(event) {\n            if (this.readonly) {\n                return;\n            }\n\n            this.focus = true;\n\n            clearTimeout(this.caretTimeoutId);\n            let pos;\n\n            this.focusText = this.$el.value;\n\n            pos = this.checkVal();\n\n            this.caretTimeoutId = setTimeout(() => {\n                if (this.$el !== document.activeElement) {\n                    return;\n                }\n\n                this.writeBuffer();\n\n                if (pos === this.mask.replace('?', '').length) {\n                    this.caret(0, pos);\n                } else {\n                    this.caret(pos);\n                }\n            }, 10);\n\n            this.$emit('focus', event);\n        },\n        onBlur(event) {\n            this.focus = false;\n            this.checkVal();\n            this.updateModelValue(event.target.value);\n\n            if (this.$el.value !== this.focusText) {\n                let e = document.createEvent('HTMLEvents');\n\n                e.initEvent('change', true, false);\n                this.$el.dispatchEvent(e);\n            }\n\n            this.$emit('blur', event);\n            this.formField.onBlur?.(event);\n        },\n        onKeyDown(event) {\n            if (this.readonly) {\n                return;\n            }\n\n            let k = event.code,\n                pos,\n                begin,\n                end;\n            let iPhone = /iphone/i.test(getUserAgent());\n\n            this.oldVal = this.$el.value;\n\n            //backspace, delete, and escape get special treatment\n            if (k === 'Backspace' || k === 'Delete' || (iPhone && k === 'Escape')) {\n                pos = this.caret();\n                begin = pos.begin;\n                end = pos.end;\n\n                if (end - begin === 0) {\n                    begin = k !== 'Delete' ? this.seekPrev(begin) : (end = this.seekNext(begin - 1));\n                    end = k === 'Delete' ? this.seekNext(end) : end;\n                }\n\n                this.clearBuffer(begin, end);\n                this.shiftL(begin, end - 1);\n                this.updateModelValue(event.target.value);\n\n                event.preventDefault();\n            } else if (k === 'Enter') {\n                // enter\n                this.$el.blur();\n                this.updateModelValue(event.target.value);\n            } else if (k === 'Escape') {\n                // escape\n                this.$el.value = this.focusText;\n                this.caret(0, this.checkVal());\n                this.updateModelValue(event.target.value);\n                event.preventDefault();\n            }\n\n            this.$emit('keydown', event);\n        },\n        onKeyPress(event) {\n            if (this.readonly) {\n                return;\n            }\n\n            var k = event.code,\n                pos = this.caret(),\n                p,\n                c,\n                next,\n                completed;\n\n            if (event.ctrlKey || event.altKey || event.metaKey || event.shiftKey || event.key === 'CapsLock' || event.key === 'Escape' || event.key === 'Tab') {\n                //Ignore\n                return;\n            } else if (k && k !== 'Enter') {\n                if (pos.end - pos.begin !== 0) {\n                    this.clearBuffer(pos.begin, pos.end);\n                    this.shiftL(pos.begin, pos.end - 1);\n                }\n\n                p = this.seekNext(pos.begin - 1);\n\n                if (p < this.len) {\n                    c = event.key;\n\n                    if (this.tests[p].test(c)) {\n                        this.shiftR(p);\n\n                        this.buffer[p] = c;\n                        this.writeBuffer();\n                        next = this.seekNext(p);\n\n                        if (/android/i.test(getUserAgent())) {\n                            //Path for CSP Violation on FireFox OS 1.1\n                            let proxy = () => {\n                                this.caret(next);\n                            };\n\n                            setTimeout(proxy, 0);\n                        } else {\n                            this.caret(next);\n                        }\n\n                        if (pos.begin <= this.lastRequiredNonMaskPos) {\n                            completed = this.isCompleted();\n                        }\n                    }\n                }\n\n                event.preventDefault();\n            }\n\n            this.updateModelValue(event.target.value);\n\n            if (completed) {\n                this.$emit('complete', event);\n            }\n\n            this.$emit('keypress', event);\n        },\n        onPaste(event) {\n            this.handleInputChange(event);\n\n            this.$emit('paste', event);\n        },\n        caret(first, last) {\n            let range, begin, end;\n\n            if (!this.$el.offsetParent || this.$el !== document.activeElement) {\n                return;\n            }\n\n            if (typeof first === 'number') {\n                begin = first;\n                end = typeof last === 'number' ? last : begin;\n\n                if (this.$el.setSelectionRange) {\n                    this.$el.setSelectionRange(begin, end);\n                } else if (this.$el['createTextRange']) {\n                    range = this.$el['createTextRange']();\n                    range.collapse(true);\n                    range.moveEnd('character', end);\n                    range.moveStart('character', begin);\n                    range.select();\n                }\n            } else {\n                if (this.$el.setSelectionRange) {\n                    begin = this.$el.selectionStart;\n                    end = this.$el.selectionEnd;\n                } else if (document['selection'] && document['selection'].createRange) {\n                    range = document['selection'].createRange();\n                    begin = 0 - range.duplicate().moveStart('character', -100000);\n                    end = begin + range.text.length;\n                }\n\n                return { begin: begin, end: end };\n            }\n        },\n        isCompleted() {\n            for (let i = this.firstNonMaskPos; i <= this.lastRequiredNonMaskPos; i++) {\n                if (this.tests[i] && this.buffer[i] === this.getPlaceholder(i)) {\n                    return false;\n                }\n            }\n\n            return true;\n        },\n        getPlaceholder(i) {\n            if (i < this.slotChar.length) {\n                return this.slotChar.charAt(i);\n            }\n\n            return this.slotChar.charAt(0);\n        },\n        seekNext(pos) {\n            while (++pos < this.len && !this.tests[pos]);\n\n            return pos;\n        },\n        seekPrev(pos) {\n            while (--pos >= 0 && !this.tests[pos]);\n\n            return pos;\n        },\n        shiftL(begin, end) {\n            let i, j;\n\n            if (begin < 0) {\n                return;\n            }\n\n            for (i = begin, j = this.seekNext(end); i < this.len; i++) {\n                if (this.tests[i]) {\n                    if (j < this.len && this.tests[i].test(this.buffer[j])) {\n                        this.buffer[i] = this.buffer[j];\n                        this.buffer[j] = this.getPlaceholder(j);\n                    } else {\n                        break;\n                    }\n\n                    j = this.seekNext(j);\n                }\n            }\n\n            this.writeBuffer();\n            this.caret(Math.max(this.firstNonMaskPos, begin));\n        },\n        shiftR(pos) {\n            let i, c, j, t;\n\n            for (i = pos, c = this.getPlaceholder(pos); i < this.len; i++) {\n                if (this.tests[i]) {\n                    j = this.seekNext(i);\n                    t = this.buffer[i];\n                    this.buffer[i] = c;\n\n                    if (j < this.len && this.tests[j].test(t)) {\n                        c = t;\n                    } else {\n                        break;\n                    }\n                }\n            }\n        },\n        handleAndroidInput(event) {\n            var curVal = this.$el.value;\n            var pos = this.caret();\n\n            if (this.oldVal && this.oldVal.length && this.oldVal.length > curVal.length) {\n                // a deletion or backspace happened\n                this.checkVal(true);\n                while (pos.begin > 0 && !this.tests[pos.begin - 1]) pos.begin--;\n\n                if (pos.begin === 0) {\n                    while (pos.begin < this.firstNonMaskPos && !this.tests[pos.begin]) pos.begin++;\n                }\n\n                this.caret(pos.begin, pos.begin);\n            } else {\n                this.checkVal(true);\n                while (pos.begin < this.len && !this.tests[pos.begin]) pos.begin++;\n\n                this.caret(pos.begin, pos.begin);\n            }\n\n            if (this.isCompleted()) {\n                this.$emit('complete', event);\n            }\n        },\n        clearBuffer(start, end) {\n            let i;\n\n            for (i = start; i < end && i < this.len; i++) {\n                if (this.tests[i]) {\n                    this.buffer[i] = this.getPlaceholder(i);\n                }\n            }\n        },\n        writeBuffer() {\n            this.$el.value = this.buffer.join('');\n        },\n        checkVal(allow) {\n            this.isValueChecked = true;\n            //try to place characters where they belong\n            let test = this.$el.value,\n                lastMatch = -1,\n                i,\n                c,\n                pos;\n\n            for (i = 0, pos = 0; i < this.len; i++) {\n                if (this.tests[i]) {\n                    this.buffer[i] = this.getPlaceholder(i);\n\n                    while (pos++ < test.length) {\n                        c = test.charAt(pos - 1);\n\n                        if (this.tests[i].test(c)) {\n                            this.buffer[i] = c;\n                            lastMatch = i;\n                            break;\n                        }\n                    }\n\n                    if (pos > test.length) {\n                        this.clearBuffer(i + 1, this.len);\n                        break;\n                    }\n                } else {\n                    if (this.buffer[i] === test.charAt(pos)) {\n                        pos++;\n                    }\n\n                    if (i < this.partialPosition) {\n                        lastMatch = i;\n                    }\n                }\n            }\n\n            if (allow) {\n                this.writeBuffer();\n            } else if (lastMatch + 1 < this.partialPosition) {\n                if (this.autoClear || this.buffer.join('') === this.defaultBuffer) {\n                    // Invalid value. Remove it and replace it with the\n                    // mask, which is the default behavior.\n                    if (this.$el.value) this.$el.value = '';\n                    this.clearBuffer(0, this.len);\n                } else {\n                    // Invalid value, but we opt to show the value to the\n                    // user and allow them to correct their mistake.\n                    this.writeBuffer();\n                }\n            } else {\n                this.writeBuffer();\n                this.$el.value = this.$el.value.substring(0, lastMatch + 1);\n            }\n\n            return this.partialPosition ? i : this.firstNonMaskPos;\n        },\n        handleInputChange(event) {\n            const isPasteEvent = event.type === 'paste';\n\n            if (this.readonly || isPasteEvent) {\n                return;\n            }\n\n            var pos = this.checkVal(true);\n\n            this.caret(pos);\n            this.updateModelValue(event.target.value);\n\n            if (this.isCompleted()) {\n                this.$emit('complete', event);\n            }\n        },\n        getUnmaskedValue() {\n            let unmaskedBuffer = [];\n\n            for (let i = 0; i < this.buffer.length; i++) {\n                let c = this.buffer[i];\n\n                if (this.tests[i] && c !== this.getPlaceholder(i)) {\n                    unmaskedBuffer.push(c);\n                }\n            }\n\n            return unmaskedBuffer.join('');\n        },\n\n        updateModelValue(value) {\n            if (this.currentVal === value) return;\n            const val = this.unmask ? this.getUnmaskedValue() : value;\n\n            this.currentVal = value;\n\n            this.writeValue(this.defaultBuffer !== val ? val : '');\n        },\n        updateValue(updateModel = true) {\n            if (this.$el) {\n                if (this.d_value == null) {\n                    this.$el.value = '';\n                    updateModel && this.updateModelValue('');\n                } else {\n                    this.$el.value = this.d_value;\n                    this.checkVal();\n\n                    setTimeout(() => {\n                        if (this.$el) {\n                            this.writeBuffer();\n                            this.checkVal();\n\n                            if (updateModel) this.updateModelValue(this.$el.value);\n                        }\n                    }, 10);\n                }\n\n                this.focusText = this.$el.value;\n            }\n        },\n        initMask() {\n            this.tests = [];\n            this.partialPosition = this.mask.length;\n            this.len = this.mask.length;\n            this.firstNonMaskPos = null;\n            this.defs = {\n                9: '[0-9]',\n                a: '[A-Za-z]',\n                '*': '[A-Za-z0-9]'\n            };\n\n            let ua = getUserAgent();\n\n            this.androidChrome = /chrome/i.test(ua) && /android/i.test(ua);\n\n            let maskTokens = this.mask.split('');\n\n            for (let i = 0; i < maskTokens.length; i++) {\n                let c = maskTokens[i];\n\n                if (c === '?') {\n                    this.len--;\n                    this.partialPosition = i;\n                } else if (this.defs[c]) {\n                    this.tests.push(new RegExp(this.defs[c]));\n\n                    if (this.firstNonMaskPos === null) {\n                        this.firstNonMaskPos = this.tests.length - 1;\n                    }\n\n                    if (i < this.partialPosition) {\n                        this.lastRequiredNonMaskPos = this.tests.length - 1;\n                    }\n                } else {\n                    this.tests.push(null);\n                }\n            }\n\n            this.buffer = [];\n\n            for (let i = 0; i < maskTokens.length; i++) {\n                let c = maskTokens[i];\n\n                if (c !== '?') {\n                    if (this.defs[c]) this.buffer.push(this.getPlaceholder(i));\n                    else this.buffer.push(c);\n                }\n            }\n\n            this.defaultBuffer = this.buffer.join('');\n            this.updateValue(false);\n        },\n        isValueUpdated() {\n            return this.unmask ? this.d_value != this.getUnmaskedValue() : this.defaultBuffer !== this.$el.value && this.$el.value !== this.d_value;\n        }\n    },\n    computed: {\n        inputClass() {\n            return [this.cx('root'), this.class];\n        },\n        rootPTOptions() {\n            return {\n                root: mergeProps(this.ptm('pcInputText', this.ptmParams), this.ptmi('root', this.ptmParams))\n            };\n        },\n        ptmParams() {\n            return {\n                context: {\n                    filled: this.$filled\n                }\n            };\n        }\n    },\n    components: {\n        InputText\n    }\n};\n</script>\n","<template>\n    <InputText\n        :id=\"id\"\n        :value=\"currentVal\"\n        :class=\"inputClass\"\n        :readonly=\"readonly\"\n        :disabled=\"disabled\"\n        :invalid=\"invalid\"\n        :size=\"size\"\n        :name=\"name\"\n        :variant=\"variant\"\n        :placeholder=\"placeholder\"\n        :fluid=\"$fluid\"\n        :unstyled=\"unstyled\"\n        @input=\"onInput\"\n        @compositionend=\"onInput\"\n        @focus=\"onFocus\"\n        @blur=\"onBlur\"\n        @keydown=\"onKeyDown\"\n        @keypress=\"onKeyPress\"\n        @paste=\"onPaste\"\n        :pt=\"rootPTOptions\"\n    />\n</template>\n\n<script>\nimport { getUserAgent } from '@primeuix/utils/dom';\nimport InputText from 'primevue/inputtext';\nimport { mergeProps } from 'vue';\nimport BaseInputMask from './BaseInputMask.vue';\n\nexport default {\n    name: 'InputMask',\n    extends: BaseInputMask,\n    inheritAttrs: false,\n    emits: ['focus', 'blur', 'keydown', 'complete', 'keypress', 'paste'],\n    inject: {\n        $pcFluid: { default: null }\n    },\n    data() {\n        return {\n            currentVal: ''\n        };\n    },\n    watch: {\n        mask(newMask, oldMask) {\n            if (oldMask !== newMask) {\n                this.initMask();\n            }\n        }\n    },\n    mounted() {\n        this.initMask();\n    },\n    updated() {\n        if (this.isValueUpdated()) {\n            this.updateValue();\n        }\n    },\n    methods: {\n        onInput(event) {\n            // Check if the event is part of a text composition process (e.g., for Asian languages).\n            // If event.isComposing is true, it means the user is still composing text and the input is not finalized.\n            if (!event.isComposing) {\n                if (this.androidChrome) this.handleAndroidInput(event);\n                else this.handleInputChange(event);\n\n                this.updateModelValue(event.target.value);\n            }\n        },\n        onFocus(event) {\n            if (this.readonly) {\n                return;\n            }\n\n            this.focus = true;\n\n            clearTimeout(this.caretTimeoutId);\n            let pos;\n\n            this.focusText = this.$el.value;\n\n            pos = this.checkVal();\n\n            this.caretTimeoutId = setTimeout(() => {\n                if (this.$el !== document.activeElement) {\n                    return;\n                }\n\n                this.writeBuffer();\n\n                if (pos === this.mask.replace('?', '').length) {\n                    this.caret(0, pos);\n                } else {\n                    this.caret(pos);\n                }\n            }, 10);\n\n            this.$emit('focus', event);\n        },\n        onBlur(event) {\n            this.focus = false;\n            this.checkVal();\n            this.updateModelValue(event.target.value);\n\n            if (this.$el.value !== this.focusText) {\n                let e = document.createEvent('HTMLEvents');\n\n                e.initEvent('change', true, false);\n                this.$el.dispatchEvent(e);\n            }\n\n            this.$emit('blur', event);\n            this.formField.onBlur?.(event);\n        },\n        onKeyDown(event) {\n            if (this.readonly) {\n                return;\n            }\n\n            let k = event.code,\n                pos,\n                begin,\n                end;\n            let iPhone = /iphone/i.test(getUserAgent());\n\n            this.oldVal = this.$el.value;\n\n            //backspace, delete, and escape get special treatment\n            if (k === 'Backspace' || k === 'Delete' || (iPhone && k === 'Escape')) {\n                pos = this.caret();\n                begin = pos.begin;\n                end = pos.end;\n\n                if (end - begin === 0) {\n                    begin = k !== 'Delete' ? this.seekPrev(begin) : (end = this.seekNext(begin - 1));\n                    end = k === 'Delete' ? this.seekNext(end) : end;\n                }\n\n                this.clearBuffer(begin, end);\n                this.shiftL(begin, end - 1);\n                this.updateModelValue(event.target.value);\n\n                event.preventDefault();\n            } else if (k === 'Enter') {\n                // enter\n                this.$el.blur();\n                this.updateModelValue(event.target.value);\n            } else if (k === 'Escape') {\n                // escape\n                this.$el.value = this.focusText;\n                this.caret(0, this.checkVal());\n                this.updateModelValue(event.target.value);\n                event.preventDefault();\n            }\n\n            this.$emit('keydown', event);\n        },\n        onKeyPress(event) {\n            if (this.readonly) {\n                return;\n            }\n\n            var k = event.code,\n                pos = this.caret(),\n                p,\n                c,\n                next,\n                completed;\n\n            if (event.ctrlKey || event.altKey || event.metaKey || event.shiftKey || event.key === 'CapsLock' || event.key === 'Escape' || event.key === 'Tab') {\n                //Ignore\n                return;\n            } else if (k && k !== 'Enter') {\n                if (pos.end - pos.begin !== 0) {\n                    this.clearBuffer(pos.begin, pos.end);\n                    this.shiftL(pos.begin, pos.end - 1);\n                }\n\n                p = this.seekNext(pos.begin - 1);\n\n                if (p < this.len) {\n                    c = event.key;\n\n                    if (this.tests[p].test(c)) {\n                        this.shiftR(p);\n\n                        this.buffer[p] = c;\n                        this.writeBuffer();\n                        next = this.seekNext(p);\n\n                        if (/android/i.test(getUserAgent())) {\n                            //Path for CSP Violation on FireFox OS 1.1\n                            let proxy = () => {\n                                this.caret(next);\n                            };\n\n                            setTimeout(proxy, 0);\n                        } else {\n                            this.caret(next);\n                        }\n\n                        if (pos.begin <= this.lastRequiredNonMaskPos) {\n                            completed = this.isCompleted();\n                        }\n                    }\n                }\n\n                event.preventDefault();\n            }\n\n            this.updateModelValue(event.target.value);\n\n            if (completed) {\n                this.$emit('complete', event);\n            }\n\n            this.$emit('keypress', event);\n        },\n        onPaste(event) {\n            this.handleInputChange(event);\n\n            this.$emit('paste', event);\n        },\n        caret(first, last) {\n            let range, begin, end;\n\n            if (!this.$el.offsetParent || this.$el !== document.activeElement) {\n                return;\n            }\n\n            if (typeof first === 'number') {\n                begin = first;\n                end = typeof last === 'number' ? last : begin;\n\n                if (this.$el.setSelectionRange) {\n                    this.$el.setSelectionRange(begin, end);\n                } else if (this.$el['createTextRange']) {\n                    range = this.$el['createTextRange']();\n                    range.collapse(true);\n                    range.moveEnd('character', end);\n                    range.moveStart('character', begin);\n                    range.select();\n                }\n            } else {\n                if (this.$el.setSelectionRange) {\n                    begin = this.$el.selectionStart;\n                    end = this.$el.selectionEnd;\n                } else if (document['selection'] && document['selection'].createRange) {\n                    range = document['selection'].createRange();\n                    begin = 0 - range.duplicate().moveStart('character', -100000);\n                    end = begin + range.text.length;\n                }\n\n                return { begin: begin, end: end };\n            }\n        },\n        isCompleted() {\n            for (let i = this.firstNonMaskPos; i <= this.lastRequiredNonMaskPos; i++) {\n                if (this.tests[i] && this.buffer[i] === this.getPlaceholder(i)) {\n                    return false;\n                }\n            }\n\n            return true;\n        },\n        getPlaceholder(i) {\n            if (i < this.slotChar.length) {\n                return this.slotChar.charAt(i);\n            }\n\n            return this.slotChar.charAt(0);\n        },\n        seekNext(pos) {\n            while (++pos < this.len && !this.tests[pos]);\n\n            return pos;\n        },\n        seekPrev(pos) {\n            while (--pos >= 0 && !this.tests[pos]);\n\n            return pos;\n        },\n        shiftL(begin, end) {\n            let i, j;\n\n            if (begin < 0) {\n                return;\n            }\n\n            for (i = begin, j = this.seekNext(end); i < this.len; i++) {\n                if (this.tests[i]) {\n                    if (j < this.len && this.tests[i].test(this.buffer[j])) {\n                        this.buffer[i] = this.buffer[j];\n                        this.buffer[j] = this.getPlaceholder(j);\n                    } else {\n                        break;\n                    }\n\n                    j = this.seekNext(j);\n                }\n            }\n\n            this.writeBuffer();\n            this.caret(Math.max(this.firstNonMaskPos, begin));\n        },\n        shiftR(pos) {\n            let i, c, j, t;\n\n            for (i = pos, c = this.getPlaceholder(pos); i < this.len; i++) {\n                if (this.tests[i]) {\n                    j = this.seekNext(i);\n                    t = this.buffer[i];\n                    this.buffer[i] = c;\n\n                    if (j < this.len && this.tests[j].test(t)) {\n                        c = t;\n                    } else {\n                        break;\n                    }\n                }\n            }\n        },\n        handleAndroidInput(event) {\n            var curVal = this.$el.value;\n            var pos = this.caret();\n\n            if (this.oldVal && this.oldVal.length && this.oldVal.length > curVal.length) {\n                // a deletion or backspace happened\n                this.checkVal(true);\n                while (pos.begin > 0 && !this.tests[pos.begin - 1]) pos.begin--;\n\n                if (pos.begin === 0) {\n                    while (pos.begin < this.firstNonMaskPos && !this.tests[pos.begin]) pos.begin++;\n                }\n\n                this.caret(pos.begin, pos.begin);\n            } else {\n                this.checkVal(true);\n                while (pos.begin < this.len && !this.tests[pos.begin]) pos.begin++;\n\n                this.caret(pos.begin, pos.begin);\n            }\n\n            if (this.isCompleted()) {\n                this.$emit('complete', event);\n            }\n        },\n        clearBuffer(start, end) {\n            let i;\n\n            for (i = start; i < end && i < this.len; i++) {\n                if (this.tests[i]) {\n                    this.buffer[i] = this.getPlaceholder(i);\n                }\n            }\n        },\n        writeBuffer() {\n            this.$el.value = this.buffer.join('');\n        },\n        checkVal(allow) {\n            this.isValueChecked = true;\n            //try to place characters where they belong\n            let test = this.$el.value,\n                lastMatch = -1,\n                i,\n                c,\n                pos;\n\n            for (i = 0, pos = 0; i < this.len; i++) {\n                if (this.tests[i]) {\n                    this.buffer[i] = this.getPlaceholder(i);\n\n                    while (pos++ < test.length) {\n                        c = test.charAt(pos - 1);\n\n                        if (this.tests[i].test(c)) {\n                            this.buffer[i] = c;\n                            lastMatch = i;\n                            break;\n                        }\n                    }\n\n                    if (pos > test.length) {\n                        this.clearBuffer(i + 1, this.len);\n                        break;\n                    }\n                } else {\n                    if (this.buffer[i] === test.charAt(pos)) {\n                        pos++;\n                    }\n\n                    if (i < this.partialPosition) {\n                        lastMatch = i;\n                    }\n                }\n            }\n\n            if (allow) {\n                this.writeBuffer();\n            } else if (lastMatch + 1 < this.partialPosition) {\n                if (this.autoClear || this.buffer.join('') === this.defaultBuffer) {\n                    // Invalid value. Remove it and replace it with the\n                    // mask, which is the default behavior.\n                    if (this.$el.value) this.$el.value = '';\n                    this.clearBuffer(0, this.len);\n                } else {\n                    // Invalid value, but we opt to show the value to the\n                    // user and allow them to correct their mistake.\n                    this.writeBuffer();\n                }\n            } else {\n                this.writeBuffer();\n                this.$el.value = this.$el.value.substring(0, lastMatch + 1);\n            }\n\n            return this.partialPosition ? i : this.firstNonMaskPos;\n        },\n        handleInputChange(event) {\n            const isPasteEvent = event.type === 'paste';\n\n            if (this.readonly || isPasteEvent) {\n                return;\n            }\n\n            var pos = this.checkVal(true);\n\n            this.caret(pos);\n            this.updateModelValue(event.target.value);\n\n            if (this.isCompleted()) {\n                this.$emit('complete', event);\n            }\n        },\n        getUnmaskedValue() {\n            let unmaskedBuffer = [];\n\n            for (let i = 0; i < this.buffer.length; i++) {\n                let c = this.buffer[i];\n\n                if (this.tests[i] && c !== this.getPlaceholder(i)) {\n                    unmaskedBuffer.push(c);\n                }\n            }\n\n            return unmaskedBuffer.join('');\n        },\n\n        updateModelValue(value) {\n            if (this.currentVal === value) return;\n            const val = this.unmask ? this.getUnmaskedValue() : value;\n\n            this.currentVal = value;\n\n            this.writeValue(this.defaultBuffer !== val ? val : '');\n        },\n        updateValue(updateModel = true) {\n            if (this.$el) {\n                if (this.d_value == null) {\n                    this.$el.value = '';\n                    updateModel && this.updateModelValue('');\n                } else {\n                    this.$el.value = this.d_value;\n                    this.checkVal();\n\n                    setTimeout(() => {\n                        if (this.$el) {\n                            this.writeBuffer();\n                            this.checkVal();\n\n                            if (updateModel) this.updateModelValue(this.$el.value);\n                        }\n                    }, 10);\n                }\n\n                this.focusText = this.$el.value;\n            }\n        },\n        initMask() {\n            this.tests = [];\n            this.partialPosition = this.mask.length;\n            this.len = this.mask.length;\n            this.firstNonMaskPos = null;\n            this.defs = {\n                9: '[0-9]',\n                a: '[A-Za-z]',\n                '*': '[A-Za-z0-9]'\n            };\n\n            let ua = getUserAgent();\n\n            this.androidChrome = /chrome/i.test(ua) && /android/i.test(ua);\n\n            let maskTokens = this.mask.split('');\n\n            for (let i = 0; i < maskTokens.length; i++) {\n                let c = maskTokens[i];\n\n                if (c === '?') {\n                    this.len--;\n                    this.partialPosition = i;\n                } else if (this.defs[c]) {\n                    this.tests.push(new RegExp(this.defs[c]));\n\n                    if (this.firstNonMaskPos === null) {\n                        this.firstNonMaskPos = this.tests.length - 1;\n                    }\n\n                    if (i < this.partialPosition) {\n                        this.lastRequiredNonMaskPos = this.tests.length - 1;\n                    }\n                } else {\n                    this.tests.push(null);\n                }\n            }\n\n            this.buffer = [];\n\n            for (let i = 0; i < maskTokens.length; i++) {\n                let c = maskTokens[i];\n\n                if (c !== '?') {\n                    if (this.defs[c]) this.buffer.push(this.getPlaceholder(i));\n                    else this.buffer.push(c);\n                }\n            }\n\n            this.defaultBuffer = this.buffer.join('');\n            this.updateValue(false);\n        },\n        isValueUpdated() {\n            return this.unmask ? this.d_value != this.getUnmaskedValue() : this.defaultBuffer !== this.$el.value && this.$el.value !== this.d_value;\n        }\n    },\n    computed: {\n        inputClass() {\n            return [this.cx('root'), this.class];\n        },\n        rootPTOptions() {\n            return {\n                root: mergeProps(this.ptm('pcInputText', this.ptmParams), this.ptmi('root', this.ptmParams))\n            };\n        },\n        ptmParams() {\n            return {\n                context: {\n                    filled: this.$filled\n                }\n            };\n        }\n    },\n    components: {\n        InputText\n    }\n};\n</script>\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}